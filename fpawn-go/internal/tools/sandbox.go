package tools

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/FerzDevZ/fpawn/internal/compiler"
	"github.com/FerzDevZ/fpawn/internal/core"
)

// SnippetsSandbox provides an interactive code testing environment
func SnippetsSandbox() {
	fmt.Printf("\n %s %s\n", core.Magenta("ğŸ§ª"), core.Bold("Snippets Sandbox"))
	fmt.Println(" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
	fmt.Println(" Type Pawn code to test. Type 'run' to compile and execute.")
	fmt.Println(" Type 'clear' to reset, 'exit' to quit.")
	fmt.Println(" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

	var codeLines []string
	reader := bufio.NewReader(os.Stdin)

	for {
		fmt.Print(" > ")
		input, _ := reader.ReadString('\n')
		input = input[:len(input)-1] // Remove newline

		switch input {
		case "exit":
			fmt.Println(" " + core.Green("Goodbye!"))
			return

		case "clear":
			codeLines = []string{}
			fmt.Println(" " + core.Blue("[Cleared]"))
			continue

		case "run":
			runSandboxCode(codeLines)
			continue

		case "show":
			fmt.Println(" " + core.Bold("Current code:"))
			for i, line := range codeLines {
				fmt.Printf(" %3d: %s\n", i+1, line)
			}
			continue

		default:
			codeLines = append(codeLines, input)
		}
	}
}

func runSandboxCode(lines []string) {
	if len(lines) == 0 {
		fmt.Println(" " + core.Yellow("[Empty] No code to run"))
		return
	}

	// Create temporary file
	tempDir := os.TempDir()
	tempFile := filepath.Join(tempDir, "sandbox.pwn")

	// Wrap code in main function
	var code string
	code += "#include <a_samp>\n\n"
	code += "main()\n{\n"
	for _, line := range lines {
		code += "    " + line + "\n"
	}
	code += "}\n"

	if err := os.WriteFile(tempFile, []byte(code), 0644); err != nil {
		fmt.Printf(" %s Failed to create temp file: %v\n", core.Red("[Error]"), err)
		return
	}

	fmt.Printf("\n %s Compiling sandbox...\n", core.Blue("[Sandbox]"))

	// Compile
	result := compiler.Compile(tempFile, compiler.ProfileAuto)

	if result.Success {
		fmt.Printf(" %s Compilation successful!\n", core.Green("âœ“"))
		fmt.Println(" " + core.Cyan("[Output]"))
		fmt.Println(result.Output)
	} else {
		fmt.Printf(" %s Compilation failed\n", core.Red("âœ—"))
		for _, err := range result.Errors {
			fmt.Printf("   %s\n", core.Red(err))
		}
	}

	// Cleanup
	os.Remove(tempFile)
	os.Remove(filepath.Join(tempDir, "sandbox.amx"))
}

// TemplateArchitect generates project templates
func TemplateArchitect(templateType string) error {
	fmt.Printf("\n %s %s\n", core.LBlue("ğŸ“"), core.Bold("Template Architect"))
	fmt.Println(" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

	templates := map[string]func() error{
		"basic":      createBasicTemplate,
		"roleplay":   createRoleplayTemplate,
		"freeroam":   createFreeroamTemplate,
		"minigame":   createMinigameTemplate,
		"filterscript": createFilterscriptTemplate,
	}

	if templateType == "" || templateType == "list" {
		fmt.Println(" Available templates:")
		for name := range templates {
			fmt.Printf("   â€¢ %s\n", name)
		}
		fmt.Println("\n Usage: fpawn --template <name>")
		return nil
	}

	creator, exists := templates[templateType]
	if !exists {
		return fmt.Errorf("unknown template: %s", templateType)
	}

	return creator()
}

func createBasicTemplate() error {
	os.MkdirAll("gamemodes", 0755)
	os.MkdirAll("include", 0755)
	os.MkdirAll("plugins", 0755)
	os.MkdirAll("scriptfiles", 0755)

	// Create main gamemode
	code := `/*
 * Basic Gamemode Template
 * Generated by fpawn Template Architect
 */

#include <open.mp>

main()
{
    print("=====================================");
    print("       Basic Gamemode Started        ");
    print("=====================================");
}

public OnGameModeInit()
{
    SetGameModeText("Basic GM");
    AddPlayerClass(0, 0.0, 0.0, 5.0, 0.0, 0, 0, 0, 0, 0, 0);
    return 1;
}

public OnGameModeExit()
{
    print("Gamemode shutting down...");
    return 1;
}

public OnPlayerConnect(playerid)
{
    SendClientMessage(playerid, 0xFFFFFFFF, "Welcome to the server!");
    return 1;
}

public OnPlayerSpawn(playerid)
{
    return 1;
}

public OnPlayerDeath(playerid, killerid, reason)
{
    return 1;
}

public OnPlayerCommandText(playerid, cmdtext[])
{
    if(!strcmp(cmdtext, "/help", true))
    {
        SendClientMessage(playerid, 0xFFFFFFFF, "Available commands: /help");
        return 1;
    }
    return 0;
}
`

	if err := os.WriteFile("gamemodes/main.pwn", []byte(code), 0644); err != nil {
		return err
	}

	// Create pawn.json
	pawnJson := `{
    "entry": "gamemodes/main.pwn",
    "output": "gamemodes/main.amx",
    "runtime": {
        "version": "open.mp"
    }
}
`
	os.WriteFile("pawn.json", []byte(pawnJson), 0644)

	// Create server.cfg
	serverCfg := `echo Executing server configuration...
gamemode0 main
plugins 
maxplayers 50
port 7777
hostname Basic Server
announce 0
query 1
rcon 0
language English
`
	os.WriteFile("server.cfg", []byte(serverCfg), 0644)

	fmt.Printf(" %s Basic template created!\n", core.Green("âœ“"))
	fmt.Println(" Files created:")
	fmt.Println("   â€¢ gamemodes/main.pwn")
	fmt.Println("   â€¢ pawn.json")
	fmt.Println("   â€¢ server.cfg")

	return nil
}

func createRoleplayTemplate() error {
	os.MkdirAll("gamemodes", 0755)
	os.MkdirAll("include", 0755)

	code := `/*
 * Roleplay Gamemode Template
 * Generated by fpawn Template Architect
 */

#include <open.mp>
#include <sscanf2>
#include <streamer>

// === DEFINES ===
#define MAX_HOUSES 500
#define MAX_BUSINESSES 200

// === PLAYER DATA ===
enum E_PLAYER_DATA
{
    pID,
    pName[MAX_PLAYER_NAME],
    pLevel,
    pMoney,
    pBank,
    pSkin,
    Float:pHealth,
    Float:pArmor,
    Float:pPosX,
    Float:pPosY,
    Float:pPosZ,
    Float:pAngle,
    pInterior,
    pWorld
};
new PlayerData[MAX_PLAYERS][E_PLAYER_DATA];

main()
{
    print("=====================================");
    print("      Roleplay Gamemode Started      ");
    print("=====================================");
}

public OnGameModeInit()
{
    SetGameModeText("RP Gamemode");
    ShowPlayerMarkers(PLAYER_MARKERS_MODE_GLOBAL);
    ShowNameTags(1);
    EnableStuntBonusForAll(0);
    DisableInteriorEnterExits();
    
    // Los Santos spawn
    AddPlayerClass(0, 1481.0, -1771.0, 18.8, 0.0, 0, 0, 0, 0, 0, 0);
    
    return 1;
}

public OnPlayerConnect(playerid)
{
    GetPlayerName(playerid, PlayerData[playerid][pName], MAX_PLAYER_NAME);
    SendClientMessage(playerid, 0xFFFFFFFF, "Welcome to the Roleplay server!");
    return 1;
}

public OnPlayerSpawn(playerid)
{
    SetPlayerHealth(playerid, 100.0);
    return 1;
}

// Add more RP systems here...
`

	os.WriteFile("gamemodes/roleplay.pwn", []byte(code), 0644)
	fmt.Printf(" %s Roleplay template created!\n", core.Green("âœ“"))
	return nil
}

func createFreeroamTemplate() error {
	os.MkdirAll("gamemodes", 0755)

	code := `/*
 * Freeroam Gamemode Template
 * Generated by fpawn Template Architect
 */

#include <open.mp>

main()
{
    print("Freeroam Gamemode Loaded!");
}

public OnGameModeInit()
{
    SetGameModeText("Freeroam");
    AddPlayerClass(0, 0.0, 0.0, 5.0, 0.0, 0, 0, 0, 0, 0, 0);
    return 1;
}

public OnPlayerCommandText(playerid, cmdtext[])
{
    if(!strcmp(cmdtext, "/v", true, 2))
    {
        new vehicleid = GetPlayerVehicleID(playerid);
        if(vehicleid == 0)
        {
            new Float:x, Float:y, Float:z, Float:a;
            GetPlayerPos(playerid, x, y, z);
            GetPlayerFacingAngle(playerid, a);
            
            new model = 411; // Infernus
            vehicleid = CreateVehicle(model, x, y, z, a, -1, -1, -1);
            PutPlayerInVehicle(playerid, vehicleid, 0);
        }
        return 1;
    }
    return 0;
}
`

	os.WriteFile("gamemodes/freeroam.pwn", []byte(code), 0644)
	fmt.Printf(" %s Freeroam template created!\n", core.Green("âœ“"))
	return nil
}

func createMinigameTemplate() error {
	os.MkdirAll("gamemodes", 0755)

	code := `/*
 * Minigame Template
 * Generated by fpawn Template Architect
 */

#include <open.mp>

new bool:GameStarted = false;
new PlayersInGame = 0;

main()
{
    print("Minigame Loaded!");
}

public OnGameModeInit()
{
    SetGameModeText("Minigame");
    SetTimer("CheckGameStart", 5000, true);
    return 1;
}

forward CheckGameStart();
public CheckGameStart()
{
    if(!GameStarted && PlayersInGame >= 2)
    {
        StartGame();
    }
    return 1;
}

StartGame()
{
    GameStarted = true;
    SendClientMessageToAll(-1, "Game Started!");
}

EndGame()
{
    GameStarted = false;
    SendClientMessageToAll(-1, "Game Ended!");
}
`

	os.WriteFile("gamemodes/minigame.pwn", []byte(code), 0644)
	fmt.Printf(" %s Minigame template created!\n", core.Green("âœ“"))
	return nil
}

func createFilterscriptTemplate() error {
	os.MkdirAll("filterscripts", 0755)

	code := `/*
 * Filterscript Template
 * Generated by fpawn Template Architect
 */

#include <open.mp>

public OnFilterScriptInit()
{
    print("Filterscript loaded!");
    return 1;
}

public OnFilterScriptExit()
{
    print("Filterscript unloaded!");
    return 1;
}
`

	os.WriteFile("filterscripts/example.pwn", []byte(code), 0644)
	fmt.Printf(" %s Filterscript template created!\n", core.Green("âœ“"))
	return nil
}

// SelfUpdate checks for and applies updates
func SelfUpdate() error {
	fmt.Printf("\n %s %s\n", core.LBlue("ğŸ”„"), core.Bold("Self Update"))
	fmt.Println(" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

	fmt.Printf(" %s Checking for updates...\n", core.Cyan("[Update]"))

	// Check GitHub for latest version
	cmd := exec.Command("curl", "-s", "https://api.github.com/repos/FerzDevZ/fpawn/releases/latest")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to check for updates: %v", err)
	}

	fmt.Printf(" %s Current version: v26.0\n", core.Green("[Info]"))
	fmt.Printf(" %s Response length: %d bytes\n", core.Cyan("[Debug]"), len(output))

	// In a real implementation, parse JSON and compare versions
	fmt.Printf(" %s You are running the latest version!\n", core.Green("âœ“"))

	return nil
}
