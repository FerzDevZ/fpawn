package tools

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/FerzDevZ/fpawn/internal/core"
)

// ScribeEntry represents a documented code item
type ScribeEntry struct {
	Name        string
	Type        string
	Params      []string
	Description string
	File        string
	Line        int
}

// ScribeArchitect generates professional project documentation
func ScribeArchitect() {
	fmt.Printf("\n %s %s\n", core.LBlue("ğŸ“œ"), core.Bold("The Scribe: Documentation Architect"))
	fmt.Println(" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
	fmt.Printf(" %s Sweeping project for documented functions...\n", core.Cyan("[Scribe]"))

	var entries []ScribeEntry
	
	// Scan for stock/public functions
	funcPattern := regexp.MustCompile(`(stock|public)\s+([A-Za-z0-9_]+)\(([^)]*)\)`)

	filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return nil
		}
		if filepath.Ext(path) == ".pwn" || filepath.Ext(path) == ".inc" {
			data, _ := os.ReadFile(path)
			lines := strings.Split(string(data), "\n")
			for i, line := range lines {
				if matches := funcPattern.FindStringSubmatch(line); len(matches) > 3 {
					entries = append(entries, ScribeEntry{
						Type:   matches[1],
						Name:   matches[2],
						Params: strings.Split(matches[3], ","),
						File:   path,
						Line:   i + 1,
					})
				}
			}
		}
		return nil
	})

	if len(entries) == 0 {
		fmt.Printf(" %s No documentable functions found.\n", core.Yellow("[Notice]"))
		return
	}

	// Generate Markdown Doc
	docFile := "DOCS_PROJECT.md"
	var out strings.Builder
	out.WriteString("# ğŸ“œ Project Documentation (Generated by FPAWN)\n\n")
	out.WriteString("Generated on: " + strings.Split(core.Bold("now"), " ")[0] + "\n\n")
	
	out.WriteString("## ğŸ—ï¸ Functions Index\n\n")
	for _, e := range entries {
		out.WriteString(fmt.Sprintf("- [%s](%s#L%d) (`%s`)\n", e.Name, e.File, e.Line, e.Type))
	}

	out.WriteString("\n## ğŸ” API Details\n\n")
	for _, e := range entries {
		out.WriteString(fmt.Sprintf("### `%s %s`\n", e.Type, e.Name))
		out.WriteString(fmt.Sprintf("- **File**: `%s` (Line %d)\n", e.File, e.Line))
		out.WriteString("- **Parameters**:\n")
		for _, p := range e.Params {
			p = strings.TrimSpace(p)
			if p != "" {
				out.WriteString(fmt.Sprintf("  - `%s`\n", p))
			}
		}
		out.WriteString("\n---\n\n")
	}

	err := os.WriteFile(docFile, []byte(out.String()), 0644)
	if err != nil {
		fmt.Printf(" %s Failed to write documentation: %v\n", core.Red("[Error]"), err)
		return
	}

	fmt.Printf(" %s Succesfully mapped %d entries.\n", core.Green("âœ“"), len(entries))
	fmt.Printf(" %s Documentation generated: %s\n", core.Green("âœ“"), docFile)
	fmt.Println(" â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
}
